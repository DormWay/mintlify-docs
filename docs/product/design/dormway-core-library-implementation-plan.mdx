---
title: "DormWay Core Library Implementation Plan"
description: "last_updated: 2025-11-17 owner: Platform status: in-progress tags:"
---

# DormWay Core Library - Comprehensive Implementation Plan

---
last_updated: 2025-11-17
owner: Platform
status: in-progress
tags:
  - '#architecture'
  - '#technical'
  - '#library'
  - '#implementation'
category: design
---

## Executive Summary

This document provides a comprehensive implementation plan for the **DormWay Core Library** (`@dormway/core`), a centralized TypeScript library that will eliminate code duplication and drift across all DormWay services. Based on analysis of the codebase, we've identified **5,000+ lines of duplicated code** across 50+ files that can be consolidated into a single, well-tested library.

**Key Benefits:**
- **Reduce duplication**: Eliminate 3 identical logger implementations, 30+ duplicate database queries, 5+ duplicate third-party clients
- **Improve consistency**: Shared types, error handling, validation, and observability across all services
- **Enable faster development**: Reusable components for new services
- **Simplify maintenance**: Single source of truth for database access, API clients, utilities
- **Better testability**: Centralized testing for core functionality

**Timeline**: 7 weeks (4 phases)
**Estimated Impact**: ~5,000 lines of duplicate code eliminated, 6 services unified

---

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Package Structure](#package-structure)
3. [Domain APIs](#domain-apis)
4. [Adapter Interfaces](#adapter-interfaces)
5. [Implementation Details](#implementation-details)
6. [Migration Strategy](#migration-strategy)
7. [Testing Strategy](#testing-strategy)
8. [Documentation Requirements](#documentation-requirements)
9. [Rollout Plan](#rollout-plan)

---

## Architecture Overview

### Design Principles

1. **Adapter Pattern**: Core library provides interfaces; services inject concrete implementations
2. **Dependency Injection**: All external dependencies (DB, HTTP, cache) are injected at initialization
3. **Zero Runtime Dependencies**: Library has minimal peer dependencies (only TypeScript, Zod)
4. **Type-First**: Full TypeScript coverage with exported types for all public APIs
5. **Observable**: Built-in structured logging and metrics for all operations
6. **Testable**: Easy to mock adapters for unit testing
7. **Backward Compatible**: Gradual migration without breaking existing services

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    @dormway/core                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐  │
│  │   Domains     │  │   Adapters    │  │   Utilities   │  │
│  ├───────────────┤  ├───────────────┤  ├───────────────┤  │
│  │ • Preferences │  │ • Aurora DB   │  │ • Logger      │  │
│  │ • Accounts    │  │ • HTTP Client │  │ • Validators  │  │
│  │ • ServiceData │  │ • Redis Cache │  │ • Formatters  │  │
│  │ • Contexts    │  │ • Ably        │  │ • Date/Time   │  │
│  │ • Campus/City │  │ • Ragie       │  │ • Error       │  │
│  │ • DayPlan     │  │ • Portkey     │  │   Handling    │  │
│  │ • Auth        │  │ • Amplitude   │  │ • Config      │  │
│  │ • Telemetry   │  │ • Customer.io │  │   Validation  │  │
│  └───────────────┘  │ • Temporal    │  └───────────────┘  │
│                     └───────────────┘                      │
└─────────────────────────────────────────────────────────────┘
                             ▲
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
   ┌────▼─────┐      ┌──────▼──────┐     ┌──────▼──────┐
   │ api-     │      │   engine    │     │ ably-relay  │
   │ router   │      │  (Temporal) │     │  (webhooks) │
   └──────────┘      └─────────────┘     └─────────────┘
```

### Initialization Pattern

```typescript
import { createDormWayCore } from '@dormway/core'

const core = createDormWayCore({
  // Database adapter (legacy naming - connects to Neon PostgreSQL)
  db: createAuroraAdapter({
    pool: pgPool, // Connects to Neon PostgreSQL via DATABASE_URL
    secretsManager: awsSecretsClient
  }),

  // HTTP adapter (for edge/serverless)
  http: createHttpAdapter({
    baseUrl: process.env.API_ROUTER_URL,
    apiKey: process.env.INTERNAL_API_KEY
  }),

  // Cache adapter
  cache: createRedisAdapter({
    url: process.env.REDIS_URL,
    password: process.env.REDIS_PASSWORD,
    ttl: {
      default: 300,
      contexts: 600,
      campus: 3600
    }
  }),

  // Real-time adapter
  realtime: createAblyAdapter({
    apiKey: process.env.ABLY_KEY,
    channels: {
      telemetry: 'telemetry',
      dayplan: 'dayplan-updates',
      contextChanges: 'context-changes'
    }
  }),

  // AI/LLM adapter
  llm: createPortkeyAdapter({
    apiKey: process.env.PORTKEY_API_KEY,
    promptRegistry: './prompts',
    defaultModel: 'gpt-4-turbo'
  }),

  // Search/knowledge adapter
  search: createRagieAdapter({
    apiKey: process.env.RAGIE_API_KEY,
    baseUrl: process.env.RAGIE_URL,
    recencyBias: 0.3
  }),

  // Analytics adapter
  analytics: createAmplitudeAdapter({
    apiKey: process.env.AMPLITUDE_API_KEY
  }),

  // Messaging adapter
  messaging: createCustomerIOAdapter({
    apiKey: process.env.CUSTOMERIO_API_KEY,
    siteId: process.env.CUSTOMERIO_SITE_ID
  }),

  // Workflow adapter
  workflows: createTemporalAdapter({
    address: process.env.TEMPORAL_ADDRESS,
    namespace: process.env.TEMPORAL_NAMESPACE,
    apiKey: process.env.TEMPORAL_API_KEY
  }),

  // Observability
  logger: createStructuredLogger({
    service: 'api-router',
    level: process.env.LOG_LEVEL || 'info',
    format: 'json'
  }),

  metrics: createMetricsClient({
    provider: 'prometheus', // or 'datadog'
    prefix: 'dormway'
  })
})

// Use domain services
const preferences = core.preferences
const contexts = core.contexts
const dayplanData = core.dayplanData
```

---

## Package Structure

```
services/shared/dormway-core/
├── src/
│   ├── index.ts                      # Main entry point
│   │
│   ├── adapters/                     # External service adapters
│   │   ├── index.ts
│   │   ├── aurora/
│   │   │   ├── aurora.adapter.ts     # PostgreSQL connection management
│   │   │   ├── connection-pool.ts    # Pool management with AWS Secrets
│   │   │   ├── transaction.helper.ts # Transaction wrapper
│   │   │   └── types.ts
│   │   ├── http/
│   │   │   ├── http.adapter.ts       # API router HTTP client
│   │   │   ├── fetch-wrapper.ts      # Retry + timeout logic
│   │   │   └── types.ts
│   │   ├── cache/
│   │   │   ├── redis.adapter.ts      # Redis client with reconnect
│   │   │   ├── cache-key-builder.ts  # Standardized cache keys
│   │   │   ├── ttl-constants.ts      # TTL presets
│   │   │   └── types.ts
│   │   ├── realtime/
│   │   │   ├── ably.adapter.ts       # Ably publish/subscribe
│   │   │   ├── channel-registry.ts   # Channel name constants
│   │   │   └── types.ts
│   │   ├── llm/
│   │   │   ├── portkey.adapter.ts    # LLM calls via Portkey
│   │   │   ├── prompt-loader.ts      # Git-based prompt registry
│   │   │   ├── json-extractor.ts     # JSON response parsing
│   │   │   ├── schemas.ts            # Response validation schemas
│   │   │   └── types.ts
│   │   ├── search/
│   │   │   ├── ragie.adapter.ts      # Document indexing/search
│   │   │   ├── partition-helper.ts   # Partition management
│   │   │   └── types.ts
│   │   ├── analytics/
│   │   │   ├── amplitude.adapter.ts  # Event tracking
│   │   │   ├── event-types.ts        # Typed event definitions
│   │   │   └── types.ts
│   │   ├── messaging/
│   │   │   ├── customerio.adapter.ts # Email/push notifications
│   │   │   ├── templates.ts          # Message templates
│   │   │   └── types.ts
│   │   ├── workflows/
│   │   │   ├── temporal.adapter.ts   # Temporal client wrapper
│   │   │   ├── workflow-registry.ts  # Workflow type registry
│   │   │   └── types.ts
│   │   └── types.ts                  # Shared adapter interfaces
│   │
│   ├── domains/                      # Business domain services
│   │   ├── index.ts
│   │   ├── preferences/
│   │   │   ├── preferences.service.ts
│   │   │   ├── types.ts
│   │   │   └── schemas.ts            # Zod validation schemas
│   │   ├── accounts/
│   │   │   ├── accounts.service.ts
│   │   │   ├── types.ts
│   │   │   └── schemas.ts
│   │   ├── service-data/
│   │   │   ├── service-data.service.ts
│   │   │   ├── types.ts
│   │   │   ├── schemas.ts
│   │   │   └── codecs.ts             # Method-specific codecs
│   │   ├── contexts/
│   │   │   ├── contexts.service.ts
│   │   │   ├── query-builder.ts      # Common context queries
│   │   │   ├── graph-traversal.ts    # Hierarchy traversal
│   │   │   ├── types.ts
│   │   │   └── schemas.ts
│   │   ├── campus/
│   │   │   ├── campus.service.ts
│   │   │   ├── housing.service.ts
│   │   │   ├── weather.service.ts
│   │   │   ├── types.ts
│   │   │   └── schemas.ts
│   │   ├── auth/
│   │   │   ├── auth.service.ts
│   │   │   ├── token-validator.ts    # Clerk JWT validation
│   │   │   ├── gateway-validator.ts  # Zuplo header validation
│   │   │   ├── demo-mode.ts          # Demo user protection
│   │   │   ├── types.ts
│   │   │   └── schemas.ts
│   │   ├── telemetry/
│   │   │   ├── telemetry.service.ts
│   │   │   ├── event-emitter.ts      # Unified event emission
│   │   │   ├── trait-sync.ts         # Amplitude trait sync
│   │   │   ├── types.ts
│   │   │   └── schemas.ts
│   │   └── dayplan-data/
│   │       ├── dayplan-data.service.ts
│   │       ├── schedule-fetcher.ts
│   │       ├── preferences-fetcher.ts
│   │       ├── context-fetcher.ts
│   │       ├── weather-fetcher.ts
│   │       ├── intelligence-fetcher.ts
│   │       ├── types.ts
│   │       └── schemas.ts
│   │
│   ├── utils/                        # Shared utilities
│   │   ├── index.ts
│   │   ├── logger/
│   │   │   ├── structured-logger.ts  # Core logger (from api-router)
│   │   │   ├── context-enricher.ts   # Log context helpers
│   │   │   └── types.ts
│   │   ├── errors/
│   │   │   ├── app-error.ts          # Base error class
│   │   │   ├── error-types.ts        # Specific error classes
│   │   │   ├── error-serializer.ts
│   │   │   └── types.ts
│   │   ├── validation/
│   │   │   ├── validators.ts         # Common validators
│   │   │   ├── schemas.ts            # Shared Zod schemas
│   │   │   └── types.ts
│   │   ├── formatting/
│   │   │   ├── course-formatter.ts
│   │   │   ├── campus-formatter.ts
│   │   │   ├── context-formatter.ts
│   │   │   └── types.ts
│   │   ├── datetime/
│   │   │   ├── timezone-utils.ts
│   │   │   ├── academic-year.ts
│   │   │   ├── state-timezone-map.ts
│   │   │   └── types.ts
│   │   ├── config/
│   │   │   ├── config-validator.ts
│   │   │   ├── env-loader.ts
│   │   │   ├── feature-flags.ts
│   │   │   └── types.ts
│   │   └── id-generation/
│   │       ├── deterministic-id.ts
│   │       ├── uuid-helpers.ts
│   │       └── types.ts
│   │
│   ├── types/                        # Global type definitions
│   │   ├── index.ts
│   │   ├── config.types.ts           # Configuration interfaces
│   │   ├── database.types.ts         # Database-related types
│   │   ├── api.types.ts              # API request/response types
│   │   ├── domain.types.ts           # Domain entity types
│   │   └── external.types.ts         # Third-party service types
│   │
│   ├── middleware/                   # Express/Koa middleware (optional)
│   │   ├── index.ts
│   │   ├── auth/
│   │   │   ├── clerk-jwt.middleware.ts
│   │   │   ├── gateway-auth.middleware.ts
│   │   │   ├── demo-readonly.middleware.ts
│   │   │   └── types.ts
│   │   ├── validation/
│   │   │   ├── request-validator.middleware.ts
│   │   │   └── types.ts
│   │   ├── error-handler/
│   │   │   ├── error-handler.middleware.ts
│   │   │   └── types.ts
│   │   └── rate-limiting/
│   │       ├── rate-limiter.middleware.ts
│   │       └── types.ts
│   │
│   └── core.ts                       # Core initialization
│
├── __tests__/                        # Tests
│   ├── unit/
│   │   ├── adapters/
│   │   ├── domains/
│   │   └── utils/
│   ├── integration/
│   │   ├── database/
│   │   ├── cache/
│   │   └── external-services/
│   └── fixtures/
│       ├── mock-data.ts
│       └── test-adapters.ts
│
├── docs/                             # Documentation
│   ├── README.md
│   ├── MIGRATION-GUIDE.md
│   ├── API-REFERENCE.md
│   ├── adapters/
│   ├── domains/
│   └── examples/
│
├── package.json
├── tsconfig.json
├── tsconfig.build.json
├── jest.config.js
├── .eslintrc.js
└── README.md
```

---

## Domain APIs

### 1. Preferences Service

**Purpose**: Unified user preference management (get/set/merge/sync)

**Current Issues**:
- API router stores preferences as separate rows per key
- Engine expects single `key='preferences'` row with JSON blob
- Mismatch causes DayPlan to miss personalization data

**API Design**:

```typescript
interface PreferencesService {
  // Get all preferences for a user (auto-hydrated from per-key rows)
  getAll(userId: string): Promise<UserPreferences>

  // Get single preference key
  get<T>(userId: string, key: string): Promise<T | null>

  // Set single preference
  set<T>(userId: string, key: string, value: T): Promise<void>

  // Deep merge preferences (for partial updates)
  merge(userId: string, updates: Partial<UserPreferences>): Promise<UserPreferences>

  // Delete preference key
  delete(userId: string, key: string): Promise<void>

  // Sync preferences to Clerk metadata
  syncToClerk(userId: string): Promise<void>

  // Listen for preference changes (via cache invalidation)
  onChange(userId: string, callback: (prefs: UserPreferences) => void): void
}

interface UserPreferences {
  studyInterval?: number
  quietHours?: { start: string; end: string }
  aiTone?: 'professional' | 'casual' | 'motivating'
  notifications?: {
    dayplan: boolean
    assignments: boolean
    weather: boolean
  }
  // ... all preference keys
}
```

**Implementation Strategy**:
1. Copy exact logic from `api-router/routes/mobile-routes.ts:4381-4488`
2. Wrap with caching layer (Redis TTL: 300s)
3. Add Clerk metadata sync hook
4. Expose HTTP adapter method for engine to call

**Files to migrate**:
- `services/api-router/src/routes/mobile-routes.ts` (lines 4381-4488)
- Database queries to/from `user_preferences` table

---

### 2. Accounts Service

**Purpose**: Account management, campus context resolution, Clerk integration

**API Design**:

```typescript
interface AccountsService {
  // Get account by user ID
  getAccount(userId: string): Promise<Account>

  // Update account fields
  updateAccount(userId: string, updates: Partial<Account>): Promise<Account>

  // Link Clerk user to DormWay account
  linkClerkUser(clerkUserId: string, accountId: string): Promise<void>

  // Resolve user's contexts (student → campus → city)
  resolveContexts(userId: string): Promise<UserContextHierarchy>

  // Get user's campus (common pattern - used 15+ times)
  getCampus(userId: string): Promise<Context>

  // Get user's city (for weather, housing)
  getCity(userId: string): Promise<Context>
}

interface UserContextHierarchy {
  student: Context
  campus: Context
  city: Context
  courses: Context[]
}
```

**Implementation Strategy**:
1. Centralize context hierarchy queries (student → campus → city)
2. Add Redis caching for campus/city lookups (TTL: 600s)
3. Integrate with Clerk for metadata sync

**Files to migrate**:
- Context hierarchy queries from `engine/activities/*.activities.ts` (30+ occurrences)

---

### 3. Service Data Service

**Purpose**: CRUD operations for `service_data` table with method-specific codecs

**API Design**:

```typescript
interface ServiceDataService {
  // Query service data with filters
  query(params: {
    contextId?: string
    userId?: string
    method: string
    startDate?: Date
    endDate?: Date
    limit?: number
  }): Promise<ServiceDataRow[]>

  // Get latest service data for a method
  latest(contextId: string, method: string): Promise<ServiceDataRow | null>

  // Insert new service data
  insert(data: ServiceDataInput): Promise<ServiceDataRow>

  // Upsert (insert or update based on unique key)
  upsert(data: ServiceDataInput): Promise<ServiceDataRow>

  // Register codec for method (typed validation)
  registerCodec<T>(method: string, codec: ServiceDataCodec<T>): void

  // Get typed service data (validates via codec)
  getTyped<T>(contextId: string, method: string): Promise<T | null>
}

interface ServiceDataCodec<T> {
  validate: (data: unknown) => T
  serialize: (data: T) => string
  deserialize: (json: string) => T
}

// Example codec registration
serviceData.registerCodec('dayplan', {
  validate: (data) => DayPlanSchema.parse(data),
  serialize: (data) => JSON.stringify(data),
  deserialize: (json) => DayPlanSchema.parse(JSON.parse(json))
})
```

**Implementation Strategy**:
1. Extract common service_data queries from api-router and engine
2. Add TTL-aware caching (different TTL per method)
3. Provide codec registry for type-safe method access

**Files to migrate**:
- Service data queries from 20+ activity files

---

### 4. Contexts Service

**Purpose**: Context graph traversal, dependency lookup, caching

**Current Issues**:
- Two overlapping implementations (`routes/contexts.ts` vs `routes/context-routes.ts`)
- Duplicate caching logic
- Inconsistent graph traversal

**API Design**:

```typescript
interface ContextsService {
  // Get context by ID
  getById(contextId: string, options?: {
    includeServiceData?: boolean
    includeChildren?: boolean
    includeDependencies?: boolean
  }): Promise<Context>

  // Get context by type and external ID
  getByType(type: ContextType, externalId: string): Promise<Context | null>

  // Search contexts by criteria
  search(criteria: ContextSearchCriteria): Promise<Context[]>

  // Get context dependencies (parents/children)
  getDependencies(contextId: string): Promise<{
    parents: Context[]
    children: Context[]
  }>

  // Get context graph (recursive up to N levels)
  getGraph(contextId: string, maxDepth?: number): Promise<ContextGraph>

  // Get all contexts for user
  getUserContexts(userId: string): Promise<Context[]>
}

interface ContextGraph {
  root: Context
  hierarchy: Context[][]  // Levels: [root], [children], [grandchildren], ...
  edges: { from: string; to: string; relationship: string }[]
}
```

**Implementation Strategy**:
1. Consolidate logic from `routes/context-routes.ts` (newer, has caching)
2. Remove `routes/contexts.ts` (legacy, raw SQL)
3. Migrate caching logic to Redis adapter
4. Add recursive CTE queries for graph traversal

**Files to migrate**:
- `services/api-router/src/routes/context-routes.ts` (lines 41-424)
- `services/api-router/src/services/context-service.ts` (lines 28-620)
- Remove `services/api-router/src/routes/contexts.ts` (legacy)

---

### 5. Campus & City Service

**Purpose**: Campus metadata, housing, weather, enrichment triggers

**API Design**:

```typescript
interface CampusService {
  // Get campus metadata
  getMetadata(campusId: string): Promise<CampusMetadata>

  // Get housing data
  getHousing(campusId: string): Promise<HousingData[]>

  // Get weather for campus
  getWeather(campusId: string, options?: {
    processed?: boolean
  }): Promise<WeatherData>

  // Trigger Temporal enrichment workflow
  triggerEnrichment(campusId: string): Promise<{ workflowId: string }>

  // Campus search (typeahead)
  search(query: string, options?: {
    limit?: number
    includeArchived?: boolean
  }): Promise<Campus[]>

  // Get city for campus
  getCity(campusId: string): Promise<Context>
}
```

**Implementation Strategy**:
1. Consolidate campus queries from api-router campus routes
2. Add weather API integration
3. Add housing metadata queries
4. Integrate with Temporal adapter for enrichment

**Files to migrate**:
- `services/api-router/src/routes/campus-routes.ts`
- `services/api-router/src/routes/dashboard-routes.ts` (weather parts)

---

### 6. Auth Service

**Purpose**: Token validation, gateway auth, demo mode protection

**API Design**:

```typescript
interface AuthService {
  // Verify Clerk JWT token
  verifyClerkToken(token: string): Promise<ClerkUser>

  // Validate Zuplo gateway headers
  validateGatewayHeaders(headers: Record<string, string>): Promise<void>

  // Check if user is demo user
  isDemoUser(userId: string): Promise<boolean>

  // Get demo mode restrictions
  getDemoRestrictions(userId: string): Promise<DemoRestrictions>

  // Express middleware generators
  middleware: {
    clerkAuth: () => RequestHandler
    gatewayAuth: () => RequestHandler
    demoReadonly: () => RequestHandler
  }
}
```

**Implementation Strategy**:
1. Migrate Clerk JWT validation from `middleware/auth.ts`
2. Migrate gateway validation from `middleware/gateway-auth.ts`
3. Migrate demo mode from `middleware/demo-readonly.ts`
4. Export middleware factories for Express/Koa

**Files to migrate**:
- `services/api-router/src/middleware/auth.ts`
- `services/api-router/src/middleware/gateway-auth.ts`
- `services/api-router/src/middleware/demo-readonly.ts`
- `services/api-router/src/middleware/app-auth.ts` (device key validation)

---

### 7. Telemetry Service

**Purpose**: Unified event tracking (Amplitude + Ably)

**API Design**:

```typescript
interface TelemetryService {
  // Identify user (set user properties)
  identify(userId: string, traits: UserTraits): Promise<void>

  // Track event
  track(userId: string, event: string, properties?: EventProperties): Promise<void>

  // Increment counter
  increment(userId: string, property: string, value?: number): Promise<void>

  // Set group properties
  group(userId: string, groupType: string, groupId: string, traits?: GroupTraits): Promise<void>

  // Publish to Ably channel
  publish(channel: string, event: string, data: any): Promise<void>

  // Subscribe to Ably channel
  subscribe(channel: string, callback: (event: string, data: any) => void): void
}

// Typed events (from existing eventTracker)
type UserEvent =
  | { event: 'dayplan_generated'; properties: { userId: string; date: string } }
  | { event: 'assignment_submitted'; properties: { assignmentId: string } }
  | { event: 'context_updated'; properties: { contextId: string; type: string } }
  // ... more typed events
```

**Implementation Strategy**:
1. Merge logic from `engine/services/eventTracker.ts` and `api-router/services/amplitude-event-tracker.ts`
2. Unify Amplitude identify/track calls
3. Add Ably publish/subscribe wrappers
4. Provide typed event definitions

**Files to migrate**:
- `services/engine/src/services/eventTracker.ts`
- `services/api-router/src/services/amplitude-event-tracker.ts`
- `services/api-router/src/routes/mobile-routes.ts` (trait sync endpoint)

---

### 8. DayPlan Data Service

**Purpose**: Assemble all inputs needed for DayPlan generation

**Current Issue**:
- Engine queries database directly with 9+ separate helpers
- Misses API router's preference hydration
- Duplicates schedule fetching logic

**API Design**:

```typescript
interface DayPlanDataService {
  // Get all data needed for DayPlan generation
  getInputs(userId: string, date: string): Promise<DayPlanInputs>

  // Get schedule/assignments for date range
  getSchedule(userId: string, startDate: string, endDate: string): Promise<ScheduleEvent[]>

  // Get hydrated preferences (from API router)
  getPreferences(userId: string): Promise<UserPreferences>

  // Get context snapshot (courses, campus, city)
  getContextState(userId: string): Promise<ContextSnapshot>

  // Get campus and city bundle
  getCampusAndCity(userId: string): Promise<CampusCityBundle>

  // Get weather for campus
  getWeather(campusId: string): Promise<WeatherData>

  // Get daily intelligence (from Ragie)
  getDailyIntelligence(userId: string): Promise<DailyIntelligence | null>

  // Get latest DayPlan
  getLatestPlan(userId: string): Promise<DayPlan | null>
}

interface DayPlanInputs {
  schedule: ScheduleEvent[]
  preferences: UserPreferences
  context: ContextSnapshot
  campus: Campus
  city: City
  weather: WeatherData
  dailyIntelligence: DailyIntelligence | null
}
```

**Implementation Strategy**:
1. Extract schedule fetching from api-router
2. Use preferences service (hydrated)
3. Use contexts service for hierarchy
4. Use campus service for weather
5. Use Ragie adapter for daily intelligence
6. Provide single `getInputs()` method for engine to call

**Files to migrate**:
- `services/engine/src/activities/dayplan.activities.ts` (lines 1934-1944, 3353-3398)
- Schedule queries from api-router

---

## Adapter Interfaces

### Base Adapter Interface

All adapters implement a common interface for observability:

```typescript
interface BaseAdapter {
  // Health check
  healthCheck(): Promise<boolean>

  // Adapter name for logging
  name: string

  // Optional: Close connections
  close?(): Promise<void>
}
```

### 1. Aurora Adapter

**Purpose**: PostgreSQL connection management, transaction helpers

**Current Implementation**:
- `services/engine/src/services/auroraDb.ts` (full implementation with AWS Secrets Manager)
- `services/ably-relay/src/services/aurora-handler.ts` (similar pattern)
- Inline `getAuroraPool()` calls in 20+ files

**Interface**:

```typescript
interface AuroraAdapter extends BaseAdapter {
  // Get connection pool
  getPool(): Promise<Pool>

  // Execute query
  query<T>(sql: string, params?: any[]): Promise<T[]>

  // Execute with transaction wrapper
  withTransaction<T>(callback: (client: PoolClient) => Promise<T>): Promise<T>

  // Get connection for manual transaction management
  getClient(): Promise<PoolClient>
}

// Factory
function createAuroraAdapter(options: {
  // Provide pre-configured pool OR connection config
  pool?: Pool
  config?: {
    host?: string
    port?: number
    database?: string
    user?: string
    password?: string
    // OR AWS Secrets Manager
    secretsManager?: {
      client: SecretsManagerClient
      secretId: string
    }
  }
  // Environment detection
  useAurora?: boolean  // process.env.USE_AURORA
  logger?: Logger
}): AuroraAdapter
```

**Implementation Details**:
- If `pool` provided, use it directly
- If `config` provided, create pool with pg library
- If `secretsManager` provided, fetch password from AWS on init
- Support environment variable fallbacks (DATABASE_URL, AURORA_*)
- Add connection pool metrics (active connections, waiting, idle)
- Auto-reconnect on connection loss

**Files to migrate**:
- `services/engine/src/services/auroraDb.ts` (primary source)
- `services/ably-relay/src/services/aurora-handler.ts`

---

### 2. HTTP Adapter

**Purpose**: API router client for edge/serverless environments

**Interface**:

```typescript
interface HttpAdapter extends BaseAdapter {
  // Generic HTTP request
  request<T>(options: {
    method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'
    path: string
    body?: any
    query?: Record<string, string>
    headers?: Record<string, string>
    timeout?: number
  }): Promise<T>

  // Convenience methods
  get<T>(path: string, query?: Record<string, string>): Promise<T>
  post<T>(path: string, body?: any): Promise<T>
  put<T>(path: string, body?: any): Promise<T>
  patch<T>(path: string, body?: any): Promise<T>
  delete<T>(path: string): Promise<T>
}

// Factory
function createHttpAdapter(options: {
  baseUrl: string
  apiKey: string
  timeout?: number  // default: 30000ms
  retries?: number  // default: 3
  retryDelay?: number  // default: 1000ms (exponential backoff)
  headers?: Record<string, string>
  logger?: Logger
}): HttpAdapter
```

**Implementation Details**:
- Use `fetch` or `axios` under the hood
- Add retry logic with exponential backoff
- Add timeout handling
- Add request/response logging
- Inject service identifier header (`X-Dormway-Service`)
- Support bearer token or API key auth

---

### 3. Redis Cache Adapter

**Purpose**: Redis client with reconnection, TTL management

**Current Implementation**:
- `services/api-router/src/services/redis-cache.ts` (400+ lines, full-featured)

**Interface**:

```typescript
interface CacheAdapter extends BaseAdapter {
  // Get cached value
  get<T>(key: string): Promise<T | null>

  // Set cached value with TTL
  set<T>(key: string, value: T, ttl?: number): Promise<void>

  // Delete cached value
  delete(key: string): Promise<void>

  // Delete by pattern
  deletePattern(pattern: string): Promise<number>

  // Check if key exists
  exists(key: string): Promise<boolean>

  // Set with expiry timestamp
  setEx<T>(key: string, value: T, expiresAt: Date): Promise<void>

  // Increment counter
  increment(key: string, amount?: number): Promise<number>

  // Get multiple keys
  mget<T>(keys: string[]): Promise<(T | null)[]>

  // Set multiple keys
  mset<T>(entries: Record<string, T>, ttl?: number): Promise<void>
}

// Factory
function createRedisAdapter(options: {
  url?: string
  host?: string
  port?: number
  password?: string
  tls?: boolean
  ttl?: {
    default?: number
    contexts?: number
    campus?: number
    weather?: number
    preferences?: number
  }
  reconnectStrategy?: {
    maxRetries: number
    delayMs: number
  }
  logger?: Logger
}): CacheAdapter
```

**Implementation Details**:
- Migrate from `services/api-router/src/services/redis-cache.ts`
- Support multiple URL environment variables (REDIS_URL, REDIS_PRIVATE_URL, DOCKER_REDIS_URL)
- Add exponential backoff reconnection
- Add connection health monitoring
- TLS support for production
- JSON serialization/deserialization built-in

**Files to migrate**:
- `services/api-router/src/services/redis-cache.ts` (primary source - 400+ lines)

---

### 4. Ably Adapter

**Purpose**: Real-time pub/sub, presence, telemetry

**Current Implementations**:
- `services/engine/src/services/ably-publisher.ts`
- `services/api-router/src/services/ably-service.ts`
- `services/ably-relay/src/services/ably-listener.ts`

**Interface**:

```typescript
interface RealtimeAdapter extends BaseAdapter {
  // Publish event to channel
  publish(channel: string, event: string, data: any): Promise<void>

  // Subscribe to channel
  subscribe(channel: string, callback: (event: string, data: any) => void): void

  // Unsubscribe from channel
  unsubscribe(channel: string): void

  // Enter presence
  enterPresence(channel: string, data?: any): Promise<void>

  // Leave presence
  leavePresence(channel: string): Promise<void>

  // Get presence members
  getPresence(channel: string): Promise<PresenceMember[]>

  // Generate auth token for client
  generateToken(clientId: string, capabilities?: string[]): Promise<string>
}

// Factory
function createAblyAdapter(options: {
  apiKey: string
  channels?: {
    telemetry?: string
    dayplan?: string
    contextChanges?: string
  }
  logger?: Logger
}): RealtimeAdapter
```

**Implementation Details**:
- Merge logic from 3 different Ably implementations
- Standard channel names via config
- Auto-reconnect on connection loss
- Presence tracking for collaborative features
- Token generation for client SDK

**Files to migrate**:
- `services/engine/src/services/ably-publisher.ts`
- `services/api-router/src/services/ably-service.ts`
- `services/ably-relay/src/services/ably-listener.ts`

---

### 5. Portkey/LLM Adapter

**Purpose**: LLM calls, prompt loading, JSON extraction

**Current Implementation**:
- `services/engine/src/utils/portkey.ts` (955 lines! Complex prompt system)

**Interface**:

```typescript
interface LLMAdapter extends BaseAdapter {
  // Call LLM with prompt
  call(options: {
    prompt: string | PromptTemplate
    variables?: Record<string, any>
    model?: string
    temperature?: number
    maxTokens?: number
    responseFormat?: 'text' | 'json'
    schema?: z.ZodSchema  // For JSON validation
  }): Promise<LLMResponse>

  // Load prompt from registry
  loadPrompt(promptId: string): Promise<PromptTemplate>

  // Extract JSON from response (handles markdown code blocks)
  extractJson<T>(response: string, schema: z.ZodSchema<T>): Promise<T>

  // Batch calls (for parallel LLM requests)
  batch(calls: LLMCallOptions[]): Promise<LLMResponse[]>
}

interface PromptTemplate {
  id: string
  template: string  // Handlebars template
  variables: string[]
  defaultModel: string
  schema?: z.ZodSchema
}

// Factory
function createPortkeyAdapter(options: {
  apiKey: string
  promptRegistry?: string  // Git repo URL or local path
  defaultModel?: string
  retries?: number
  logger?: Logger
}): LLMAdapter
```

**Implementation Details**:
- Migrate entire prompt system from `engine/utils/portkey.ts`
- Git-based prompt registry with caching
- Handlebars template rendering
- JSON extraction with markdown code block handling
- Schema validation with Zod
- Retry logic for Claude 502 errors
- Support multiple LLM providers (GPT-4, Claude, Gemini)

**Files to migrate**:
- `services/engine/src/utils/portkey.ts` (955 lines - primary source)
- `services/shared/utils/prompt-loader.ts` (existing partial implementation)
- `prompts/` directory (prompt templates)

---

### 6. Ragie Adapter

**Purpose**: Document indexing, search, partition management

**Current Implementations**:
- `services/api-router/src/services/ragie-service.ts` (516 lines)
- `services/engine/src/services/ragie.service.ts` (similar)

**Interface**:

```typescript
interface SearchAdapter extends BaseAdapter {
  // Index document
  indexDocument(options: {
    content: string
    metadata: DocumentMetadata
    partition?: string
  }): Promise<{ documentId: string }>

  // Index file (PDF, DOCX, etc.)
  indexFile(options: {
    file: Buffer | Readable
    filename: string
    metadata: DocumentMetadata
    partition?: string
  }): Promise<{ documentId: string }>

  // Search documents
  search(options: {
    query: string
    partitions?: string[]
    limit?: number
    recencyBias?: number
    filters?: Record<string, any>
  }): Promise<SearchResult[]>

  // Delete document
  deleteDocument(documentId: string): Promise<void>

  // List documents
  listDocuments(options: {
    partition?: string
    limit?: number
    offset?: number
  }): Promise<Document[]>

  // Get document source
  getDocument(documentId: string): Promise<Document>
}

// Factory
function createRagieAdapter(options: {
  apiKey: string
  baseUrl?: string
  recencyBias?: number  // 0.0-1.0
  webhookSecret?: string
  logger?: Logger
}): SearchAdapter
```

**Implementation Details**:
- Merge from two Ragie service implementations
- Fallback logic for SDK + REST endpoints
- Chunk deduplication
- Partition management helpers
- Recency bias reranking

**Files to migrate**:
- `services/api-router/src/services/ragie-service.ts` (516 lines - primary source)
- `services/engine/src/services/ragie.service.ts`

---

### 7. Amplitude Adapter

**Purpose**: Event tracking, user identification

**Current Implementations**:
- `services/engine/src/services/eventTracker.ts`
- `services/api-router/src/services/amplitude-event-tracker.ts`
- `services/dormway-lockedin/src/lib/amplitude-typed.ts`

**Interface**:

```typescript
interface AnalyticsAdapter extends BaseAdapter {
  // Identify user (set user properties)
  identify(userId: string, traits: UserTraits): Promise<void>

  // Track event
  track(userId: string, event: string, properties?: EventProperties): Promise<void>

  // Increment user property
  increment(userId: string, property: string, amount?: number): Promise<void>

  // Set group properties
  group(userId: string, groupType: string, groupId: string, traits?: GroupTraits): Promise<void>

  // Batch events (for high-throughput scenarios)
  batch(events: AnalyticsEvent[]): Promise<void>
}

// Typed events
type AnalyticsEvent =
  | { userId: string; event: 'dayplan_generated'; properties: DayPlanGeneratedProps }
  | { userId: string; event: 'assignment_submitted'; properties: AssignmentSubmittedProps }
  // ... more typed events

// Factory
function createAmplitudeAdapter(options: {
  apiKey: string
  ingestionUrl?: string
  batchSize?: number  // default: 100
  flushInterval?: number  // default: 10000ms
  logger?: Logger
}): AnalyticsAdapter
```

**Implementation Details**:
- Merge event tracking from engine and api-router
- Unified event type definitions
- Batching for performance
- Auto-flush on interval
- Error handling with retry

**Files to migrate**:
- `services/engine/src/services/eventTracker.ts`
- `services/api-router/src/services/amplitude-event-tracker.ts`
- `services/dormway-lockedin/src/lib/amplitude-typed.ts` (event types)

---

### 8. Customer.io Adapter

**Purpose**: Email/push notifications, transactional messages

**Current Implementation**:
- `services/engine/src/services/customerio.ts` (100 lines)
- `services/engine/src/services/customerio-push.ts`

**Interface**:

```typescript
interface MessagingAdapter extends BaseAdapter {
  // Send transactional email
  sendEmail(options: {
    to: string
    templateId: string
    data?: Record<string, any>
  }): Promise<void>

  // Send push notification
  sendPush(options: {
    userId: string
    title: string
    message: string
    data?: Record<string, any>
  }): Promise<void>

  // Update user traits (for segmentation)
  updateTraits(userId: string, traits: Record<string, any>): Promise<void>

  // Track event (for behavioral campaigns)
  trackEvent(userId: string, event: string, data?: Record<string, any>): Promise<void>

  // Register device for push
  registerDevice(userId: string, deviceToken: string, platform: 'ios' | 'android'): Promise<void>
}

// Factory
function createCustomerIOAdapter(options: {
  apiKey: string
  siteId: string
  templates?: Record<string, string>  // templateName → templateId
  logger?: Logger
}): MessagingAdapter
```

**Implementation Details**:
- Migrate from engine Customer.io services
- Template name → ID mapping
- Device registration for push
- Error handling with retry

**Files to migrate**:
- `services/engine/src/services/customerio.ts`
- `services/engine/src/services/customerio-push.ts`

---

### 9. Temporal Adapter

**Purpose**: Workflow client wrapper, signal/query helpers

**Interface**:

```typescript
interface WorkflowAdapter extends BaseAdapter {
  // Start workflow
  startWorkflow<T>(options: {
    workflowType: string
    workflowId: string
    args?: any[]
    taskQueue?: string
  }): Promise<WorkflowHandle<T>>

  // Get workflow handle
  getWorkflow<T>(workflowId: string): Promise<WorkflowHandle<T>>

  // Signal workflow
  signal(workflowId: string, signalName: string, args?: any[]): Promise<void>

  // Query workflow
  query<T>(workflowId: string, queryName: string, args?: any[]): Promise<T>

  // Cancel workflow
  cancel(workflowId: string): Promise<void>

  // Get workflow status
  getStatus(workflowId: string): Promise<WorkflowStatus>
}

// Factory
function createTemporalAdapter(options: {
  address: string
  namespace: string
  apiKey?: string
  taskQueue?: string
  logger?: Logger
}): WorkflowAdapter
```

**Implementation Details**:
- Wrap Temporal client for consistent error handling
- Standard workflow ID generation
- Signal/query type safety
- Workflow registry for common workflows

---

## Utilities

### 1. Structured Logger

**Current State**: Exact duplicate in api-router and engine (270 lines each)

**Files**:
- `services/api-router/src/utils/structuredLogger.ts`
- `services/engine/src/utils/structuredLogger.ts`

**Implementation**: Copy verbatim from api-router (newest)

**Interface**:

```typescript
interface Logger {
  debug(message: string, context?: LogContext): void
  info(message: string, context?: LogContext): void
  warn(message: string, context?: LogContext): void
  error(message: string, error?: Error, context?: LogContext): void
}

function createStructuredLogger(options: {
  service: string
  level?: 'debug' | 'info' | 'warn' | 'error'
  format?: 'json' | 'pretty'
  context?: LogContext
}): Logger

interface LogContext {
  [key: string]: any
  // Common context fields
  traceId?: string
  userId?: string
  workflowId?: string
  activityId?: string
  requestId?: string
}
```

---

### 2. Error Handling

**Current State**: AppError class duplicated

**Files**:
- `services/api-router/src/middleware/error-handler.ts`
- `services/api-router/src/utils/app-error.ts`

**Implementation**:

```typescript
class AppError extends Error {
  constructor(
    message: string,
    public statusCode: number = 500,
    public isOperational: boolean = true,
    public context?: Record<string, any>
  ) {
    super(message)
    this.name = this.constructor.name
    Error.captureStackTrace(this, this.constructor)
  }
}

class ValidationError extends AppError {
  constructor(message: string, context?: Record<string, any>) {
    super(message, 400, true, context)
  }
}

class AuthenticationError extends AppError {
  constructor(message: string, context?: Record<string, any>) {
    super(message, 401, true, context)
  }
}

class DatabaseError extends AppError {
  constructor(message: string, context?: Record<string, any>) {
    super(message, 500, true, context)
  }
}

class ExternalServiceError extends AppError {
  constructor(service: string, message: string, context?: Record<string, any>) {
    super(`${service} error: ${message}`, 502, true, { service, ...context })
  }
}
```

---

### 3. Validation

**Common Schemas**:

```typescript
import { z } from 'zod'

// UUID validation
export const uuidSchema = z.string().uuid()

// Coordinates
export const coordinatesSchema = z.object({
  latitude: z.number().min(-90).max(90),
  longitude: z.number().min(-180).max(180)
})

// Pagination
export const paginationSchema = z.object({
  page: z.number().int().positive().default(1),
  limit: z.number().int().positive().max(100).default(20),
  offset: z.number().int().nonnegative().optional()
})

// Date range
export const dateRangeSchema = z.object({
  startDate: z.string().datetime(),
  endDate: z.string().datetime()
}).refine(data => new Date(data.startDate) <= new Date(data.endDate), {
  message: 'startDate must be before endDate'
})

// Context type
export const contextTypeSchema = z.enum([
  'student',
  'campus',
  'city',
  'building',
  'course',
  'organization'
])
```

---

### 4. Date/Time Utilities

**Current State**: 3 separate implementations

**Files**:
- `services/api-router/src/utils/timezone-utils.ts`
- `services/engine/src/utils/timezone.utils.ts`
- `services/engine/src/activities/timezone-helpers.ts`

**Implementation**: Consolidate all three

**Interface**:

```typescript
// Get timezone for state
function getTimezoneForState(state: string): string

// Get timezone for city
function getTimezoneForCity(cityName: string, state: string): string

// Convert between timezones
function convertTimezone(date: Date, fromTz: string, toTz: string): Date

// Format date for display
function formatDate(date: Date, timezone: string, format: string): string

// Get current academic year
function getCurrentAcademicYear(date: Date): { start: Date; end: Date }

// Add current date to text (for LLM context)
function ensureDateInText(text: string): string
```

---

### 5. Formatting

**Common Patterns**:

```typescript
// Course formatting
function formatCourseName(course: { code: string; title: string }): string {
  return `${course.code} — ${course.title}`
}

// Campus formatting
function formatCampusName(campus: { name: string; state: string }): string {
  return `${campus.name}, ${campus.state}`
}

// Context-type-specific formatting
function buildFriendlyName(context: Context): string {
  switch (context.type) {
    case 'student': return context.metadata.name || 'Student'
    case 'campus': return formatCampusName(context.metadata)
    case 'course': return formatCourseName(context.metadata)
    // ... etc
  }
}
```

---

## Migration Strategy

### Phase 1: Foundation (Week 1-2)

**Goal**: Set up package, migrate logging, config, errors

**Tasks**:
1. Create package structure (`services/shared/dormway-core/`)
2. Set up TypeScript build (dual output: CommonJS + ESM)
3. Set up testing infrastructure (Jest)
4. Migrate structured logger (exact copy from api-router)
5. Migrate config types
6. Migrate AppError classes
7. Set up CI/CD for package
8. Publish v0.1.0-alpha to npm (or private registry)

**Deliverables**:
- Package published
- Logger working in api-router (parallel to existing)
- Config types exported
- Error classes exported

**Validation**:
- Import `@dormway/core` in api-router
- Use logger in one route (parallel to existing)
- Verify structured logs match existing format

---

### Phase 2: Database & LLM (Week 3-4)

**Goal**: Migrate database connection, context queries, LLM client

**Tasks**:
1. Migrate Aurora adapter from engine
2. Migrate context query patterns
3. Migrate Portkey/LLM client (955 lines!)
4. Migrate prompt system
5. Update api-router to use Aurora adapter (1 service first)
6. Update engine to use LLM adapter (1 activity first)
7. Run integration tests
8. Publish v0.2.0-alpha

**Deliverables**:
- Aurora adapter working in engine
- Context queries centralized
- LLM client working in engine
- Prompt system working

**Validation**:
- Engine can generate DayPlan using new adapters
- Context queries return same results
- LLM calls work identically

---

### Phase 3: Third-Party Integrations (Week 5-6)

**Goal**: Migrate Ragie, Customer.io, Ably, Amplitude

**Tasks**:
1. Migrate Ragie adapter
2. Migrate Customer.io adapter
3. Migrate Ably adapter
4. Migrate Amplitude adapter
5. Update api-router to use new adapters
6. Update engine to use new adapters
7. Run integration tests
8. Publish v0.3.0-beta

**Deliverables**:
- All third-party integrations centralized
- api-router using adapters
- engine using adapters
- ably-relay using adapters

**Validation**:
- Ragie search returns same results
- Customer.io emails send correctly
- Ably messages publish correctly
- Amplitude events track correctly

---

### Phase 4: Utilities & Domain Services (Week 7)

**Goal**: Migrate utilities, finalize domain services

**Tasks**:
1. Migrate date/time utilities
2. Migrate validation schemas
3. Migrate formatting utilities
4. Finalize preferences service
5. Finalize accounts service
6. Finalize service data service
7. Finalize contexts service
8. Finalize dayplan data service
9. Publish v1.0.0

**Deliverables**:
- All utilities centralized
- All domain services working
- Full documentation
- Migration guide for other services

**Validation**:
- api-router fully migrated
- engine fully migrated
- All tests passing
- No regressions

---

## Testing Strategy

### Unit Tests

**Coverage Target**: 80%+

**Test Structure**:
```
__tests__/unit/
├── adapters/
│   ├── aurora.adapter.test.ts
│   ├── http.adapter.test.ts
│   ├── redis.adapter.test.ts
│   └── ...
├── domains/
│   ├── preferences.service.test.ts
│   ├── contexts.service.test.ts
│   └── ...
└── utils/
    ├── logger.test.ts
    ├── errors.test.ts
    └── ...
```

**Mock Strategy**:
- Mock database with `pg-mem` or `testcontainers`
- Mock HTTP with `nock`
- Mock Redis with `redis-mock`
- Mock third-party services with `nock` or custom mocks

---

### Integration Tests

**Test Structure**:
```
__tests__/integration/
├── database/
│   ├── contexts-queries.test.ts
│   ├── service-data-queries.test.ts
│   └── ...
├── cache/
│   ├── redis-caching.test.ts
│   └── ...
└── external-services/
    ├── ragie.test.ts (with test partition)
    ├── portkey.test.ts (with test prompts)
    └── ...
```

**Requirements**:
- Use test database (Docker container)
- Use test Redis instance
- Use test partitions for Ragie
- Use test Temporal namespace

---

### Contract Tests

**Purpose**: Ensure adapters match expected interfaces

**Example**:
```typescript
describe('AuroraAdapter Contract', () => {
  let adapter: AuroraAdapter

  beforeAll(() => {
    adapter = createAuroraAdapter({ /* test config */ })
  })

  it('implements BaseAdapter', () => {
    expect(adapter).toHaveProperty('healthCheck')
    expect(adapter).toHaveProperty('name')
  })

  it('implements query method', async () => {
    const result = await adapter.query('SELECT 1 as test')
    expect(result).toEqual([{ test: 1 }])
  })

  // ... more contract tests
})
```

---

### Regression Tests

**Purpose**: Ensure migration doesn't break existing functionality

**Strategy**:
1. Run existing service tests with new library
2. Compare outputs before/after migration
3. Use snapshot testing for complex outputs
4. Monitor production metrics during rollout

---

## Documentation Requirements

### 1. README.md

**Contents**:
- Quick start guide
- Installation instructions
- Basic usage examples
- Link to full documentation

---

### 2. API Reference

**Contents**:
- All public APIs documented
- All adapters documented
- All domain services documented
- All utilities documented
- Generated from TSDoc comments

**Tool**: Use `typedoc` to generate from TSDoc

---

### 3. Migration Guide

**Contents**:
- Step-by-step migration for each service
- Code examples (before/after)
- Common pitfalls
- Rollback strategy
- Testing checklist

**Sections**:
- Migrating from direct database access
- Migrating from Supabase
- Migrating from inline third-party clients
- Migrating from duplicate utilities

---

### 4. Architecture Docs

**Contents**:
- High-level architecture diagram
- Adapter pattern explanation
- Dependency injection guide
- Extension guide (adding new adapters)

---

### 5. Examples

**Contents**:
- Example: Setting up in Express app
- Example: Setting up in Temporal worker
- Example: Setting up in serverless function
- Example: Testing with mocks
- Example: Custom adapter implementation

---

## Rollout Plan

### Pre-Rollout

**Checklist**:
- [ ] Package published to npm (or private registry)
- [ ] All tests passing (unit + integration)
- [ ] Documentation complete
- [ ] Migration guide reviewed
- [ ] Rollback plan documented

---

### Rollout Stages

#### Stage 1: api-router (Week 1-2)
1. Install `@dormway/core` in api-router
2. Migrate logger (parallel to existing)
3. Migrate Aurora adapter (parallel to existing)
4. Migrate context queries (one route at a time)
5. Run tests after each migration
6. Deploy to staging
7. Monitor metrics (latency, errors)
8. Deploy to production (canary rollout)

#### Stage 2: engine (Week 3-4)
1. Install `@dormway/core` in engine
2. Migrate logger
3. Migrate Aurora adapter
4. Migrate LLM client (one activity at a time)
5. Migrate Ragie client
6. Migrate Customer.io client
7. Run tests after each migration
8. Deploy to staging
9. Monitor workflow success rates
10. Deploy to production (canary rollout)

#### Stage 3: ably-relay (Week 5)
1. Install `@dormway/core` in ably-relay
2. Migrate logger
3. Migrate Aurora adapter
4. Migrate Ably client
5. Run tests
6. Deploy to staging
7. Deploy to production

#### Stage 4: Other Services (Week 6-7)
1. dormway-admin
2. dormway-lockedin
3. dormway-crews

---

### Monitoring & Validation

**Metrics to Monitor**:
- Database query latency (should be identical)
- Cache hit rates (should improve with centralized caching)
- Third-party API call success rates
- Error rates (should stay flat or decrease)
- Memory usage (should decrease due to connection pooling)

**Validation Checklist**:
- [ ] All existing tests pass
- [ ] No increase in error rates
- [ ] No increase in latency
- [ ] No regressions in functionality
- [ ] Logs are consistent
- [ ] Metrics are healthy

---

### Rollback Strategy

**If issues arise**:
1. Revert to previous version of service
2. Keep `@dormway/core` installed (no harm)
3. Investigate issue
4. Fix in `@dormway/core`
5. Republish package
6. Retry rollout

**Critical Issues**:
- Database connection failures → Rollback immediately
- Third-party API failures → Rollback immediately
- Data integrity issues → Rollback immediately + investigate

**Non-Critical Issues**:
- Logging format differences → Fix in next release
- Performance regressions < 10% → Fix in next release
- Missing error context → Fix in next release

---

## Success Metrics

### Code Reduction
- **Target**: Eliminate 5,000+ lines of duplicate code
- **Measurement**: Line count before/after in each service

### Maintenance Burden
- **Target**: Single location for database queries, third-party clients
- **Measurement**: Number of files touching database/third-party APIs

### Developer Velocity
- **Target**: New services can bootstrap faster
- **Measurement**: Time to add new service with all integrations

### Reliability
- **Target**: Reduce errors due to inconsistent implementations
- **Measurement**: Error rates before/after

### Observability
- **Target**: Consistent logging across all services
- **Measurement**: Log format consistency, metric coverage

---

## Open Questions & Decisions

### 1. Package Distribution

**Options**:
- Private npm registry (Verdaccio)
- GitHub Packages
- Monorepo with workspaces

**Decision**: Use monorepo with workspaces (easiest for now)

---

### 2. Versioning Strategy

**Options**:
- Semantic versioning (major.minor.patch)
- Date-based versioning (YYYY.MM.DD)

**Decision**: Semantic versioning (standard practice)

---

### 3. Breaking Changes

**Question**: How to handle breaking changes?

**Strategy**:
- Major version bumps for breaking changes
- Deprecation warnings for 1-2 minor versions before removal
- Migration guides for each major version

---

### 4. Adapter Extensibility

**Question**: Should consumers be able to add custom adapters?

**Answer**: Yes! Document adapter interface for extensions.

---

## Next Steps

1. **Review this document** with engineering team
2. **Prioritize** which adapters/domains to build first
3. **Assign owners** for each phase
4. **Create Linear issues** for each task
5. **Start Phase 1**: Foundation (logging, config, errors)

---

## Appendix

### A. Current Duplication Summary

| Component | Instances | Files | Lines |
|-----------|-----------|-------|-------|
| Structured Logger | 2 | 2 | 540 |
| Aurora Connection | 3 | 3 | 400 |
| Context Queries | 30+ | 15+ | 1000+ |
| Portkey Client | 1 | 1 | 955 |
| Ragie Client | 2 | 2 | 1000+ |
| Ably Client | 3 | 3 | 300 |
| Customer.io | 2 | 2 | 200 |
| Amplitude | 3 | 3 | 300 |
| Redis Cache | 1 | 1 | 400 |
| Timezone Utils | 3 | 3 | 200 |
| **Total** | **50+** | **35+** | **~5,295** |

---

### B. Service Migration Order

1. **api-router** (highest impact, most stable)
2. **engine** (most complexity, highest duplication)
3. **ably-relay** (simplest, good test case)
4. **dormway-admin** (medium complexity)
5. **dormway-lockedin** (frontend, less critical)
6. **dormway-crews** (Python, may need wrapper)

---

### C. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Database connection issues | Medium | High | Extensive testing, canary rollout |
| Third-party API breakage | Low | Medium | Contract tests, staging validation |
| Performance regression | Medium | Medium | Load testing, monitoring |
| Data integrity issues | Low | Critical | Transaction tests, rollback plan |
| Developer adoption | Medium | Medium | Good docs, examples, support |

---

### D. References

- [API Router Route Audit](Worklogs/2025-11-17-api-router-route-audit.md)
- [Original DormWay Core Library Design](Design/DormWay-Core-Library.md)
- [DormWay Platform Architecture](../Architecture/DormWay Platform Architecture.md)

---

**Document Status**: Draft for Review
**Last Updated**: 2025-11-17
**Owner**: Platform Team
**Next Review**: After Phase 1 completion
