---
title: "DormWay Widget System"
description: "The DormWay widget system provides a standardized framework for creating and managing widgets across the application. It follows a clear architecture with de..."
---

# DormWay Widget System

> **See Also**: [Home & Widgets](/docs/engineering/architecture/sot-home-widgets) for the canonical widget system source of truth, including the January 2026 iOS unified widget system with CollapsibleWidgetContainer, UpNextCard, and WidgetStackView.

## Overview

The DormWay widget system provides a standardized framework for creating and managing widgets across the application. It follows a clear architecture with defined components and data flow patterns.

**January 2026 Update**: The iOS app now implements a unified widget system with:
- `CollapsibleWidgetContainer` - Glassmorphic container with collapse/expand behavior
- `WidgetStackView` - Container orchestrating 4 collapsible widgets (Schedule, Tasks, Term, Campus)
- `UpNextCard` - Current/next event display with quick actions
- `UniversalCourseCard` - Dark glassmorphic course cards with mesh gradients

## Architecture

The widget system follows these architectural principles:

1. **Data Layer**: Strongly-typed data models in Models/
2. **Provider Layer**: Data managers that extend BaseWidgetDataManager
3. **Presentation Layer**: Widget views that extend EnhancedWidgetView
4. **Coordination**: WidgetDataCoordinator for central management

## Creating a New Widget

### Using the Widget Creation Script

The easiest way to create a new widget is to use the script:

```bash
./Scripts/create_widget.sh MyWidget .blue
```

This will create all the necessary files with proper templates.

### Manual Creation Steps

1. Create a data model in Models/
2. Create a data manager in Core/Utilities/
3. Create a widget view in Views/Dashboard/Widgets/
4. Update WidgetType.swift to add your widget type
5. Update WidgetRegistration.swift to initialize your widget data manager

## Widget Components

### Data Models

Data models represent the widget's content and state:

```swift
struct MyWidgetData: Codable {
    let title: String
    let items: [WidgetItem]
    let lastUpdated: Date
}
```

### Data Managers

Data managers handle data fetching and state management:

```swift
class MyWidgetDataManager: BaseWidgetDataManager {
    override func fetchData() async throws -> MyWidgetData {
        // Fetch and return widget data
    }
    
    override func getLastError() -> DWError? {
        // Return last error if any
    }
}
```

### Widget Views

Widget views handle presentation and user interaction:

```swift
struct MyWidgetView: EnhancedWidgetView {
    let data: MyWidgetData
    let state: WidgetState
    
    var body: some View {
        // Widget content
    }
}
```

## Using Widgets

### In Views

To use a widget in a view:

```swift
struct MyView: View {
    @ObservedObject var dataManager: MyWidgetDataManager
    
    var body: some View {
        EnhancedMyWidgetView(
            data: dataManager.dataState,
            state: .standard
        )
    }
}
```

### Getting Data Managers

Get a data manager from the coordinator:

```swift
let dataManager = WidgetDataCoordinator.shared.getDataManager(for: .myWidget) as? MyWidgetDataManager
```

## Error Handling

Widgets integrate with the app's error handling system:

```swift
switch dataState {
case .error(let message, let retryAction):
    // Get rich error from data manager
    if let dataManager = WidgetDataCoordinator.shared.getDataManager(for: .yourWidgetType) as? YourWidgetDataManager,
       let error = dataManager.getLastError() {
        // Use rich error view
        EnhancedWidgetErrorView(
            error: error,
            color: yourWidgetType.color
        )
    } else {
        // Fallback to basic error display
        EnhancedWidgetErrorView(
            message: message,
            retryAction: retryAction,
            color: yourWidgetType.color
        )
    }
```

## Available Widgets

The system includes several pre-built widgets:

- Assignments Widget
- Commute Widget
- Events Widget
- Focus Widget
- Meals Widget
- Schedule Widget
- Tasks Widget
- Wellness Widget

Each widget follows the same architecture but implements domain-specific functionality.

## Best Practices

1. **Use the widget creation script** for new widgets
2. **Follow the standard architecture** for consistency
3. **Implement proper error handling**
4. **Use the design system** for styling
5. **Keep widgets focused** on a single responsibility
6. **Handle offline states** appropriately
7. **Implement proper data refresh** strategies

## Resources

- Widget Implementation Guide
- Error Handling Guide
- Design System Integration
- Testing Guidelines

## ðŸ”— Related

*Backlinks and related notes will appear here*
